{"repository_name":"nbchannel","body":"# nbchannel\n\n![Send.cr CI](https://img.shields.io/github/workflow/status/wyhaines/nbchannel.cr/NBChannel.cr%20CI?style=for-the-badge&logo=GitHub)\n[![GitHub release](https://img.shields.io/github/release/wyhaines/nbchannel.cr.svg?style=for-the-badge)](https://github.com/wyhaines/nbchannel.cr/releases)\n![GitHub commits since latest release (by SemVer)](https://img.shields.io/github/commits-since/wyhaines/nbchannel.cr/latest?style=for-the-badge)\n\nThis is a subclass of the standard Crystal Channel to make it into a non-blocking Channel implementation. The normal Crystal Channel blocks on receive, and on send if the channel the channel has no buffer, or if the fixed-size buffer is full. This non-blocking channel implementation makes it possible to send and receive messages asynchronously, with no blocking on either receive or send.\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n   ```yaml\n   dependencies:\n     nbchannel:\n       github: wyhaines/nbchannel.cr\n   ```\n\n2. Run `shards install`\n\n## Usage\n\n```crystal\nrequire \"nbchannel\"\n```\n\nAn instance of `NBChannel` is created in almost exactly the same way as standard Crystal `Channel`. The only difference is that an `NBChannel` has infinite capacity, so there is no capacity argument to `#new`.\n\n```crystal\nchannel = NBChannel(String).new\n```\n\nOnce created, any Fiber/Thread should be able to `#send` to an `NBChannel` without ever blocking on the send.\n\n```crystal\nchannel.send(\"I am a message.\")\n```\n\nMessages can be received from a channel in a blocking or a nonblocking manner.\n\n```crystal\nchannel = NBChannel(String).new\nspawn channel.send(\"I am a message.\")\nmsg = channel.receive # This will block until a message is sent.\n```\n\n```crystal\nchannel = NBChannel(String).new\nspawn do\n  x = rand.seconds * 1.0\n  puts \"sleeping #{x}\"\n  sleep x\n  channel.send(\"Gotcha!\")\nend\n\ny = rand.seconds\nputs \"waiting #{y}\"\nsleep y\n\nputs channel.receive? || \"You escaped the trap!\"\n```\n\n## Contributing\n\n1. Fork it (<https://github.com/wyhaines/nbchannel/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [Kirk Haines](https://github.com/wyhaines) - creator and maintainer\n\n![GitHub code size in bytes](https://img.shields.io/github/languages/code-size/wyhaines/nbchannel.cr?style=for-the-badge)\n![GitHub issues](https://img.shields.io/github/issues/wyhaines/nbchannel.cr?style=for-the-badge)\n","program":{"html_id":"nbchannel/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"locations":[],"repository_name":"nbchannel","program":true,"enum":false,"alias":false,"const":false,"types":[{"html_id":"nbchannel/NBChannel","path":"NBChannel.html","kind":"class","full_name":"NBChannel(T)","name":"NBChannel","abstract":false,"superclass":{"html_id":"nbchannel/Channel","kind":"class","full_name":"Channel","name":"Channel"},"ancestors":[{"html_id":"nbchannel/Channel","kind":"class","full_name":"Channel","name":"Channel"},{"html_id":"nbchannel/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"nbchannel/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/nbchannel.cr","line_number":1,"url":"https://github.com/wyhaines/nbchannel.cr/blob/ea6517a837270361695244d14c4b03d84660f113/src/nbchannel.cr#L1"}],"repository_name":"nbchannel","program":false,"enum":false,"alias":false,"const":false,"constants":[{"id":"VERSION","name":"VERSION","value":"\"0.1.0\""}],"constructors":[{"html_id":"new-class-method","name":"new","abstract":false,"location":{"filename":"src/nbchannel.cr","line_number":4,"url":"https://github.com/wyhaines/nbchannel.cr/blob/ea6517a837270361695244d14c4b03d84660f113/src/nbchannel.cr#L4"},"def":{"name":"new","visibility":"Public","body":"_ = NBChannel(T).allocate\n_.initialize\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"html_id":"receive?:T?-instance-method","name":"receive?","doc":"Receives a value from the channel.\nIf there is a value waiting, it is returned immediately. Otherwise, this method blocks until a value is sent to the channel.\n\nReturns `nil` if the channel is closed or closes while waiting for receive.","summary":"<p>Receives a value from the channel.</p>","abstract":false,"location":{"filename":"src/nbchannel.cr","line_number":30,"url":"https://github.com/wyhaines/nbchannel.cr/blob/ea6517a837270361695244d14c4b03d84660f113/src/nbchannel.cr#L30"},"def":{"name":"receive?","return_type":"T | ::Nil","visibility":"Public","body":"receive_impl(nonblocking: true) do\n  return nil\nend"}}]}]}}